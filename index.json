[{"categories":["vim"],"content":"原文链接：https://blog.csdn.net/scaleqiao/article/details/45153379 ","date":"2021-06-06","objectID":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/:0:0","tags":["vim"],"title":"vim基本用法","uri":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"},{"categories":["vim"],"content":"文件命令 vim file1 file2 //打开多个文件 :E //打开文件 :bn //打开下一个文件 :bp //打开上一个文件 :e file //关闭当前文档，打开新文档 :gf //打开光标所在字符串的文件名 :x //保存并退出 :Sex //水平分割一个窗口，并浏览文件系统 :Vex //垂直分割一个窗口，并浏览文件系统 ","date":"2021-06-06","objectID":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/:0:1","tags":["vim"],"title":"vim基本用法","uri":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"},{"categories":["vim"],"content":"光标移动 gg //到文件头部 G //到文件尾部 nG //到文件第n行 ctrl+f //下翻一屏 ctrl+d //上翻一屏 zz //将当前行显示在屏幕中央 zt //将当前行显示在屏幕顶部 zb //将当前行显示在屏幕底部 ","date":"2021-06-06","objectID":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/:0:2","tags":["vim"],"title":"vim基本用法","uri":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"},{"categories":["vim"],"content":"剪切复制 yy //复制当前行 nyy //复制当前行以下n行 dd //剪切当前行 ndd //剪切当前以下n行 P //在光标之前粘贴 p //在光标之后粘贴 ","date":"2021-06-06","objectID":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/:0:3","tags":["vim"],"title":"vim基本用法","uri":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"},{"categories":["vim"],"content":"查找替换 /sth //在后面文本中查找sth ?sth //在前面文本中查找sth n //向后查找一个 N //向前查找一个 :s/old/new //在当前行将old替换成new :s/old/new/g //在整个文本中将old替换成new :%s/^/xxx/g //在文本每行行首加入xxx :%s/$/xxx/g //在文本每行行末加入xxx :n1,n2s/old/new/g //在文本第n1，n2范围进行替换 ","date":"2021-06-06","objectID":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/:0:4","tags":["vim"],"title":"vim基本用法","uri":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"},{"categories":["vim"],"content":"撤销重做 U //撤销 \u003cctrl\u003e+r //重做 ","date":"2021-06-06","objectID":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/:0:5","tags":["vim"],"title":"vim基本用法","uri":"/vim%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"},{"categories":["UVM","python","验证自动化"],"content":"1.总体思路 在搭建验证框架时经常要输入很多重复性的代码，有两种快速获得验证的方法，一种是复制原有的框架代码，在代码上面修改，一种是利用脚本语言快速生成代码。本文通过python脚本，快速生成agent的代码，提高工作效率。 ","date":"2021-05-16","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90agent%E4%BB%A3%E7%A0%81/:0:1","tags":["UVM","验证自动化","python"],"title":"自动化生成agent代码","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90agent%E4%BB%A3%E7%A0%81/"},{"categories":["UVM","python","验证自动化"],"content":"2.python脚本 利用open、write函数创建SV文件，写入UVM框架代码。 code_gen.py: #coding=utf-8 import sys name = input(\"input agentname:\\n\") f = open(name+\"_pkg.sv\", 'w+', encoding=\"utf-8\") f.write(\"`include \\\"uvm_macros.svh\\\"\\n\\n\") f.write(\"package \"+name+\"_pkg;\\n\\n\") f.write(\"import uvm_pkg::*;\\n\\n\") name_trans = name + \"_trans\" f.write(\"class \"+name_trans+\" extends uvm_sequence_item;\\n\") f.write(\"\\tfunction new(string name=\\\"\"+name_trans+\"\\\");\\n\") f.write(\"\\t\\tsuper.new(name);\\n\") f.write(\"\\tendfunction\\n\\n\") f.write(\"\\t//输入变量\\n\") f.write(\"\\trand ;\\n\") f.write(\"\\trand ;\\n\") f.write(\"\\t`uvm_object_utils_begin(\"+name_trans+\")\\n\") f.write(\"\\t\\t`uvm_field_\\n\") f.write(\"\\t\\t`uvm_field_\\n\") f.write(\"\\t`uvm_object_utils_end\\n\") f.write(\"\\nendclass\\n\") name_seq = name+\"_seq\" f.write(\"\\nclass \"+name_seq+\" extends uvm_sequence;\\n\") f.write(\"\\t`uvm_object_utils(\"+name_seq+\")\\n\\n\") f.write(\"\\tfunction new(string name=\\\"\"+name_seq+\"\\\");\\n\") f.write(\"\\t\\tsuper.new(name);\\n\") f.write(\"\\tendfunction\\n\\n\") f.write(\"\\tvirtual task body();\\n\") f.write(\"\\t\\t\"+name_trans+\" tr;\\n\") f.write(\"\\t\\trepeat(10) begin\\n\") f.write(\"\\t\\t\\t`uvm_do(tr)\\n\") f.write(\"\\t\\tend\\n\") f.write(\"\\t\\tendtask\\n\") f.write(\"endclass\\n\\n\") name_sqr = name+\"_sqr\" f.write(\"class \"+name_sqr+\" extends uvm_sequencer#(\"+name_trans+\");\\n\") f.write(\"\\t`uvm_component_utils(\"+name_sqr+\")\\n\\n\") f.write(\"\\tfunction new(string name=\\\"\"+name_sqr+\"\\\", uvm_component parent=null);\\n\") f.write(\"\\t\\tsuper.new(name, parent);\\n\") f.write(\"\\tendfunction\\n\") f.write(\"endclass\\n\\n\") name_drv = name+\"_drv\" f.write(\"class \"+name_drv+\" extends uvm_driver#(\"+name_trans+\");\\n\") f.write(\"\\t`uvm_component_utils(\"+name_drv+\");\\n\\n\") f.write(\"\\tfunction new(string name=\\\"\"+name_drv+\"\\\", uvm_component parent=null);\\n\") f.write(\"\\t\\tsuper.new(name,parent);\\n\") f.write(\"\\tendfunction\\n\\n\") f.write(\"\\t function void set_interface();\\n\") f.write(\"\\t\\t//设置接口\\n\\n\") f.write(\"\\tendfunction\\n\\n\") f.write(\"\\t\"+name_trans+\" tmp;\\n\") f.write(\"\\ttask main_phase(uvm_phase phase);\\n\") f.write(\"\\t\\tforever begin\\n\") f.write(\"\\t\\t\\tseq_item_port.get_next_item(tmp);\\n\") f.write(\"\\t\\t\\t//驱动\\n\\n\") f.write(\"\\t\\t\\tseq_item_port.item_done();\\n\") f.write(\"\\t\\tend\\n\") f.write(\"\\tendtask\\n\\n\") f.write(\"endclass\\n\\n\") name_mon = name + \"_mom\" f.write(\"class \"+name_mon+\" extends uvm_monitor#(\"+name_trans+\");\\n\") f.write(\"\\t`uvm_component_utils(\"+name_mon+\")\\n\\n\") f.write(\"\\tuvm_analysis_port#(\"+name_trans+\") ap;\\n\\n\") f.write(\"\\tfunction new(string name=\\\"\"+name_mon+\"\\\", uvm_component parent=null);\\n\") f.write(\"\\t\\tsuper.new(name, parent);\\n\") f.write(\"\\t\\tap = new(\\\"ap_mon\\\",this);\\n\") f.write(\"\\tendfunction\\n\\n\") f.write(\"\\ttask main_phase(uvm_phase phase);\\n\") f.write(\"\\t\\t//驱动\\n\\n\\n\") f.write(\"\\tendtask\\n\") f.write(\"endclass\\n\\n\") name_agnt = name+\"_agent\" f.write(\"class \"+name_agnt+\" extends uvm_agent;\\n\") f.write(\"\\t`uvm_component_utils(\"+name_agnt+\")\\n\\n\") f.write(\"\\tfunction new(string name=\\\"\"+name_agnt+\"\\\", uvm_component parent=null);\\n\") f.write(\"\\tsuper.new(name, parent);\\n\") f.write(\"\\tendfunction\\n\\n\") f.write(\"\\t\"+name_drv+\" drv;\\n\") f.write(\"\\t\"+name_mon+\" mon;\\n\") f.write(\"\\t\"+name_sqr+\" sqr;\\n\") f.write(\"\\tfunction void build_phase(uvm_phase phase);\\n\") f.write(\"\\t\\tdrv = \"+name_drv+\"::type_id::create(\\\"\"+name_drv+\"\\\", this);\\n\") f.write(\"\\t\\tmon = \"+name_mon+\"::type_id::create(\\\"\"+name_mon+\"\\\", this);\\n\") f.write(\"\\t\\tsqr = \"+name_sqr+\"::type_id::create(\\\"\"+name_sqr+\"\\\", this);\\n\") f.write(\"\\tendfunction\\n\\n\") f.write(\"\\tfunction void connect_phase(uvm_phase phase);\\n\") f.write(\"\\t\\tsuper.connect_phase(phase);\\n\") f.write(\"\\t\\tdrv.seq_item_port.connect(sqr.seq_item_export);\\n\") f.write(\"\\tendfunction\\n\\n\") f.write(\"endclass\\n\") f.write(\"\\nendpackage\\n\") f.close() ","date":"2021-05-16","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90agent%E4%BB%A3%E7%A0%81/:0:2","tags":["UVM","验证自动化","python"],"title":"自动化生成agent代码","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90agent%E4%BB%A3%E7%A0%81/"},{"categories":["UVM","python","验证自动化"],"content":"3.生成结果 python3 ./code_gen.py 生成文件test_pkg: `include \"uvm_macros.svh\" package test_pkg; import uvm_pkg::*; class test_trans extends uvm_sequence_item; function new(string name=\"test_trans\"); super.new(name); endfunction //输入变量 rand ; rand ; `uvm_object_utils_begin(test_trans) `uvm_field_ `uvm_field_ `uvm_object_utils_end endclass class test_seq extends uvm_sequence; `uvm_object_utils(test_seq) function new(string name=\"test_seq\"); super.new(name); endfunction virtual task body(); test_trans tr; repeat(10) begin `uvm_do(tr) end endtask endclass class test_sqr extends uvm_sequencer#(test_trans); `uvm_component_utils(test_sqr) function new(string name=\"test_sqr\", uvm_component parent=null); super.new(name, parent); endfunction endclass class test_drv extends uvm_driver#(test_trans); `uvm_component_utils(test_drv); function new(string name=\"test_drv\", uvm_component parent=null); super.new(name,parent); endfunction function void set_interface(); //设置接口 endfunction test_trans tmp; task main_phase(uvm_phase phase); forever begin seq_item_port.get_next_item(tmp); //驱动 seq_item_port.item_done(); end endtask endclass class test_mom extends uvm_monitor#(test_trans); `uvm_component_utils(test_mom) uvm_analysis_port#(test_trans) ap; function new(string name=\"test_mom\", uvm_component parent=null); super.new(name, parent); ap = new(\"ap_mon\",this); endfunction task main_phase(uvm_phase phase); //驱动 endtask endclass class test_agent extends uvm_agent; `uvm_component_utils(test_agent) function new(string name=\"test_agent\", uvm_component parent=null); super.new(name, parent); endfunction test_drv drv; test_mom mon; test_sqr sqr; function void build_phase(uvm_phase phase); drv = test_drv::type_id::create(\"test_drv\", this); mon = test_mom::type_id::create(\"test_mom\", this); sqr = test_sqr::type_id::create(\"test_sqr\", this); endfunction function void connect_phase(uvm_phase phase); super.connect_phase(phase); drv.seq_item_port.connect(sqr.seq_item_export); endfunction endclass endpackage ","date":"2021-05-16","objectID":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90agent%E4%BB%A3%E7%A0%81/:0:3","tags":["UVM","验证自动化","python"],"title":"自动化生成agent代码","uri":"/%E8%87%AA%E5%8A%A8%E5%8C%96%E7%94%9F%E6%88%90agent%E4%BB%A3%E7%A0%81/"},{"categories":["UVM","MCDF"],"content":"寄存器模型中存储了DUT寄存器中的地址和数据信息，方便寄存器的读写，简化参考模型，便于覆盖率收集等特点。本文以MCDF的控制寄存器为例搭建含有寄存器模型的验证结构。 ","date":"2021-04-21","objectID":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/:0:0","tags":["UVM","MCDF","RGM"],"title":"含寄存器模型验证结构搭建","uri":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["UVM","MCDF"],"content":"1. 控制寄存器功能描述 接口 psel:APB总线选择信号 paddr:APB总线地址总线 pwr:APB总线读写信号 pwdata:APB总线写入数据总线 pwdata:APB总线读取数据总线 pen:APB总线使能信号 pready:读写完成标志位 pslverr:总线错误标准位 error_clr:清除slave_node错误标志位 slv_en:slave_node使能控制位 slvx_id:通道x ID号 slvx_len:通道x数据包长度 slvx_free_slot:通道x可用fifo数量 slvx_parity_err:通道x奇偶校验标志位 寄存器 last_st, cur_st：用于表示APB总线状态 ctrl_men：MCDF控制寄存器 ro_men：reg_if模块中只读寄存器 ","date":"2021-04-21","objectID":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/:0:1","tags":["UVM","MCDF","RGM"],"title":"含寄存器模型验证结构搭建","uri":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["UVM","MCDF"],"content":"2.验证结构 控制寄存器模块可通过APB总线进行读取和配置，可将控制寄存器分为两部分进行验证，一部分是模拟外部总线访问设计模块，一部分是模拟设计内部信号观察控制寄存器的反应。APB_agent用于访问控制寄存器模块的APB总线，reg_agent用于模拟设计内部信号。 APB_agent中APB_seq产生随机的读写命令，通过driver发送至DUT。monitor用于监测总线变化，监测数据通过predictor、adapter最终传入寄存器模型。寄存器模型在APB总线每次被读写时更新。当monitor监测到总线数据传输完成时，同时触发寄存器模型更新和scoreboard（先缓存至analysis fifo）. scoreboard在触发后，读取寄存器模型中更新的值，作为参考设计的值，通过后门访问，直接获取DUT中的真实值，对比后输出结果。 ","date":"2021-04-21","objectID":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/:0:2","tags":["UVM","MCDF","RGM"],"title":"含寄存器模型验证结构搭建","uri":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["UVM","MCDF"],"content":"3.APB总线 AMBA总线介绍可参考此文档 AMBA总线包含AHB（高级高性能总线）、ASB（高级系统总线）、APB（高级外设总线）。APB总线状态机和时序如下： ","date":"2021-04-21","objectID":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/:0:3","tags":["UVM","MCDF","RGM"],"title":"含寄存器模型验证结构搭建","uri":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["UVM","MCDF"],"content":"4.验证环境搭建 AMBA总线介绍可参考此文档 APB总线APB_pkg.sv： `include \"uvm_macros.svh\" `define APB_DAT 32 `define APB_ADDR 8 package APB_pkg; import uvm_pkg::*; class APB_item extends uvm_sequence_item; rand bit[`APB_ADDR-1:0] paddr; rand bit[`APB_DAT-1:0] pwdata; rand bit[`APB_DAT-1:0] prdata; rand bit pwr; `uvm_object_utils_begin(APB_item) `uvm_field_int(paddr, UVM_ALL_ON) `uvm_field_int(pwdata, UVM_ALL_ON) `uvm_field_int(prdata, UVM_ALL_ON) `uvm_field_int(pwr, UVM_ALL_ON) `uvm_object_utils_end /* constraint addr_con { paddr dist {8'h00:/8, 8'h04:/8, 8'h08:/8, 8'h0C:/8, 8'h80:/8, 8'h84:/8, 8'h88:/8, 8'h8C:/8, 8'h90:/8, 8'h94:/8, 8'h98:/8, 8'h9C:/8}; } */ function new(string name = \" \"); super.new(name); endfunction : new endclass class APB_seq extends uvm_sequence; `uvm_object_utils(APB_seq) function new(string name=\" \"); super.new(name); endfunction virtual task body(); APB_item tr; #200 forever begin `uvm_do(tr) end endtask endclass class APB_sqr extends uvm_sequencer#(APB_item); `uvm_component_utils(APB_sqr) function new(string name=\"APB_sqr\", uvm_component parent=null); super.new(name,parent); endfunction endclass class APB_driver extends uvm_driver#(APB_item); `uvm_component_utils(APB_driver) function new(string name = \"APB_driver\", uvm_component parent); super.new(name, parent); endfunction virtual reg_interface APB_vif; function void set_interface(virtual reg_interface reg_vif); APB_vif = reg_vif; endfunction task main_phase(uvm_phase phase); //uvm_sequence_item tmp; APB_item t; APB_idle(); //@(APB_vif.rstn); forever begin seq_item_port.get_next_item(t); if (t.pwr == 0) begin APB_read(t); end if (t.pwr == 1) begin APB_write(t); end seq_item_port.item_done(); end endtask task APB_idle(); APB_vif.apb_driver.psel \u003c = 0; APB_vif.apb_driver.pen \u003c = 0; endtask task APB_write(APB_item tmp); //@(APB_vif.pslverr|APB_vif.pready); //while(APB_vif.apb_driver.pslverr); @APB_vif.apb_driver; if( APB_vif.apb_driver.pready ) return; fork //@(!(APB_vif.pslverr|APB_vif.pready)); //@(!APB_vif.pslverr); //@(!APB_vif.pready); APB_vif.apb_driver.psel \u003c = 1; //markdonwn问题， 实际为非阻塞赋值“\u003c=” APB_vif.apb_driver.pen \u003c = 0; APB_vif.apb_driver.paddr \u003c = tmp.paddr; APB_vif.apb_driver.pwdata \u003c = tmp.pwdata; APB_vif.apb_driver.pwr \u003c = tmp.pwr; join @APB_vif.apb_driver APB_vif.apb_driver.pen \u003c = 1; @APB_vif.apb_driver fork APB_vif.apb_driver.pen \u003c = 0; APB_vif.apb_driver.psel \u003c = 0; join endtask task APB_read(APB_item tmp); //while(APB_vif.apb_driver.pslverr); @APB_vif.apb_driver; if (APB_vif.apb_driver.pready) return; fork //@(!(APB_vif.pslverr|APB_vif.pready)); APB_vif.apb_driver.psel \u003c = 1; APB_vif.apb_driver.pen \u003c = 0; APB_vif.apb_driver.paddr \u003c = tmp.paddr; APB_vif.apb_driver.pwr \u003c = tmp.pwr; join @APB_vif.apb_driver APB_vif.apb_driver.pen \u003c = 1; @APB_vif.apb_driver fork tmp.prdata = APB_vif.apb_driver.prdata; APB_vif.apb_driver.pen \u003c = 0; APB_vif.apb_driver.psel \u003c = 0; join endtask endclass class APB_monitor extends uvm_monitor; `uvm_component_utils(APB_monitor) uvm_analysis_port#(APB_item) ap; APB_item tmp; int s; virtual reg_interface reg_intf; function void set_interface(virtual reg_interface vif); reg_intf = vif; endfunction function new(string name=\"APB_monitor\", uvm_component parent); super.new(name, parent); ap = new(\"mon_ap\",this); endfunction task main_phase(uvm_phase phase); forever begin @reg_intf.apb_sample; // `uvm_info(\"DEBUG\",$sformatf(\"psel:%h pen:%h\", reg_intf.apb_sample.psel, reg_intf.apb_sample.pen), UVM_LOW); if (reg_intf.apb_sample.pslverr) continue; if (s == 0) begin if (reg_intf.apb_sample.pready) continue; end if (reg_intf.apb_sample.psel) begin s = 1; if (reg_intf.apb_sample.pen) begin if (s != 2) begin s = 2; tmp = new(\"APB_monitor\"); tmp.pwr = reg_intf.apb_sample.pwr; tmp.paddr = reg_intf.apb_sample.paddr; tmp.prdata =reg_intf.apb_sample.prdata; tmp.pwdata = reg_intf.apb_sample.pwdata; ap.write(tmp); end end end else begin s = 0; end end endtask endclass class APB_agent extends uvm_agent; `uvm_component_utils(APB_agent) function new(string na","date":"2021-04-21","objectID":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/:0:4","tags":["UVM","MCDF","RGM"],"title":"含寄存器模型验证结构搭建","uri":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["UVM","MCDF"],"content":"5.运行 运行 make run ","date":"2021-04-21","objectID":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/:0:5","tags":["UVM","MCDF","RGM"],"title":"含寄存器模型验证结构搭建","uri":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["UVM","MCDF"],"content":"6.查看覆盖率 make result ","date":"2021-04-21","objectID":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/:0:6","tags":["UVM","MCDF","RGM"],"title":"含寄存器模型验证结构搭建","uri":"/%E5%90%AB%E5%AF%84%E5%AD%98%E5%99%A8%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%E7%BB%93%E6%9E%84%E7%9A%84%E6%90%AD%E5%BB%BA/"},{"categories":["UVM","python"],"content":"1.总体思路 通过正态分布generator产生数据传递item，最终通过driver将数据打印至日志文件，利用python脚本绘制分布图，检验产生数据是否正确 产生正态分布数据有两种方法，第一种是在利用SV中的权重分布模拟正态函数分布，第二种是利用DPI接口实现正态函数。考虑到实现难易程度，选择后者。总体框架如下图所示。 ","date":"2021-04-12","objectID":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/:0:1","tags":["UVM","DPI","C","python"],"title":"正态分布随机化item","uri":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/"},{"categories":["UVM","python"],"content":"2.在C中实现正态分布函数 实现正态分布函数有两种方法，一种是采用泰勒展开式，计算出最终值，一种是通过中心-极限定理得出正态分布。正态函数的泰勒展开式 -_-|| … 一般采用中心-极限定理比较方便。 中心-极限定理的大致解释，每次从这些总体中随机抽取 n 个抽样，一共抽 m 次。 然后把这 m 组抽样分别求出平均值。 这些平均值的分布接近正态分布。 #include\u003csvdpi.h\u003e //dpi头文件，仿真器自带 #include\u003cstdlib.h\u003e unsigned int get_normal() { unsigned int dat=0; //产生数据 unsigned char i; unsigned int seed; //随机种子 seed = rand(); srand(seed); for (i=0;i\u003c10;i++) { dat += rand()%99; //0~99随机数求和 } return dat/i; //返回平均值 } ","date":"2021-04-12","objectID":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/:0:2","tags":["UVM","DPI","C","python"],"title":"正态分布随机化item","uri":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/"},{"categories":["UVM","python"],"content":"3.UVM搭建 测试平台由代码： `include \"uvm_macros.svh\" import \"DPI-C\" function bit [31:0] get_normal(); //导入C函数 import uvm_pkg::*; class my_trans extends uvm_sequence_item; //定义my_trans bit [31:0] dat; `uvm_object_utils_begin(my_trans) `uvm_field_int(dat,UVM_ALL_ON) `uvm_object_utils_end function new(string name =\" \"); super.new(name); dat = get_normal(); endfunction virtual function void do_print(uvm_printer printer); // TODO Auto-generated function stub //super.do_print(printer); //printer.print_field(\"dat\", dat, $bits(dat), UVM_DEC); endfunction : do_print endclass class my_sequence extends uvm_sequence; //定义my_sequence `uvm_object_utils(my_sequence) function new(string name = \"my_sequence\"); super.new(name); endfunction task body(); my_trans dat_trans; repeat(100000) begin #1 `uvm_do(dat_trans) end endtask endclass class my_sequencer extends uvm_sequencer#(.REQ(my_trans),.RSP(my_trans)); //定义my_sequencer `uvm_component_utils(my_sequencer) function new(string name = \"my_sequencer\", uvm_component parent); super.new(name,parent); endfunction endclass class my_driver extends uvm_driver#(.REQ(my_trans),.RSP(my_trans)); //定义my_driver `uvm_component_utils(my_driver) function new(string name, uvm_component parent); super.new(name,parent); endfunction virtual task main_phase(uvm_phase phase); REQ req; uvm_default_printer.knobs.default_radix=UVM_DEC; forever begin seq_item_port.get_next_item(req); req.print(); seq_item_port.item_done(); end endtask endclass class my_env extends uvm_env; //定义my_env `uvm_component_utils(my_env) my_sequencer sqr; my_driver drv; function new(string name, uvm_component parent); super.new(name, parent); endfunction virtual function void build_phase(uvm_phase phase); super.build_phase(phase); drv = my_driver::type_id::create(\"drv\", this); sqr = my_sequencer::type_id::create(\"sqr\", this); endfunction virtual function void connect_phase(uvm_phase phase); super.connect_phase(phase); drv.seq_item_port.connect(sqr.seq_item_export); endfunction endclass class test0 extends uvm_test; my_env env; `uvm_component_utils(test0) function new(string name, uvm_component parent = null); super.new(name,parent); endfunction virtual function void build_phase(uvm_phase phase); super.build_phase(phase); env = my_env::type_id::create(\"env\", this); endfunction : build_phase virtual task main_phase(uvm_phase phase); my_sequence dat_seq; super.main_phase(phase); phase.raise_objection(this); dat_seq = my_sequence::type_id::create(\"dat_seq\"); dat_seq.start(env.sqr); phase.drop_objection(this); endtask : main_phase endclass testbench: module tb; initial begin run_test(\"test0\"); end endmodule ","date":"2021-04-12","objectID":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/:0:3","tags":["UVM","DPI","C","python"],"title":"正态分布随机化item","uri":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/"},{"categories":["UVM","python"],"content":"4. 利用python脚本提取数据，查看结果 VCS最终打印数据： -------------------------------- Name Type Size Value -------------------------------- dat_trans my_trans - @572 dat integral 32 'd43 -------------------------------- 利用python脚本提取dat的数值： import matplotlib import matplotlib.pyplot as plt f = open(\"sim.log\") line = f.readlines() dat=[] for tmp in line: s = tmp.split() for i in range(0,len(s)-1): if s[i] == \" \": s.pop(i) if len(s) \u003e 3: if s[0]==\"dat\": if s[1] == \"integral\": dat.append(int(s[3][2:])) # 提取数据 plt.hist(dat,100,(0,99)) plt.show() ","date":"2021-04-12","objectID":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/:0:4","tags":["UVM","DPI","C","python"],"title":"正态分布随机化item","uri":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/"},{"categories":["UVM","python"],"content":"5. makefile文件编写 vcs仿真器makefile： VCS = vcs -f tb.list +vc ../tb/gen.c\\ -full64 -debug_all -sverilog -timescale=\"1ns/1ps\" -l log.txt \\ +vpi \\ +define+UVM_OBJECT_MUST_HAVE_CONSTRUCTOR \\ $(UVM_HOME)/src/dpi/uvm_dpi.cc -CFLAGS -DVCS SIM = ./simv -l sim.log +UVM_TIMEOUT=100000000 DISP = python3 analyze_dat.py gui: $(SIM) -gui comp: $(VCS) sim: $(SIM) disp: $(DISP) run: $(VCS) $(SIM) $(DISP) clean: cp makefile ../makefile cp tb.list ../tb.list cp analyze_dat.py ../analyze_dat.py rm -rf * mv ../makefile makefile mv ../tb.list tb.list mv ../analyze_dat.py analyze_dat.py ","date":"2021-04-12","objectID":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/:0:5","tags":["UVM","DPI","C","python"],"title":"正态分布随机化item","uri":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/"},{"categories":["UVM","python"],"content":"6. 运行结果 make运行 make run 最终结果： ","date":"2021-04-12","objectID":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/:0:6","tags":["UVM","DPI","C","python"],"title":"正态分布随机化item","uri":"/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E9%9A%8F%E6%9C%BAitem/"}]